---
import BaseLayout from "./BaseLayout.astro";
import Cusdis from "../components/Cusdis.astro"; // ← added

// Accept both ways MDX can pass props: direct or nested under `frontmatter`
type MaybeDate = string | Date | undefined;

const props = Astro.props as Record<string, unknown>;

// Prefer top-level keys, fall back to `frontmatter` if present
const fm = (props.frontmatter ?? {}) as Record<string, unknown>;

const title       = (props.title       ?? fm.title)       as string;
const description = (props.description ?? fm.description) as string;
const tags        = (props.tags        ?? fm.tags        ?? []) as string[];

const rawPub: MaybeDate = (props.pubDate     ?? fm.pubDate)     as MaybeDate;
const rawUpd: MaybeDate = (props.updatedDate ?? fm.updatedDate) as MaybeDate;

// --- safe date helpers ---
function toValidDate(v: unknown): Date | null {
  if (!v) return null;
  const d = v instanceof Date ? v : new Date(v as any);
  return Number.isNaN(d.getTime()) ? null : d;
}

const pub = toValidDate(rawPub);
const upd = toValidDate(rawUpd);

const publishedISO = pub?.toISOString();
const updatedISO   = upd?.toISOString();

const human = (d: Date | null) =>
  d
    ? d.toLocaleDateString("en-US", {
        weekday: "short",
        month: "short",
        day: "2-digit",
        year: "numeric",
      })
    : "";

// OG image slug
const slug = Astro.url.pathname.split("/").filter(Boolean).pop() ?? "";
---


<BaseLayout title={`${title} | Shuvo’s Notes`}>
  <Fragment slot="head">
    <meta name="description" content={description} />
    {tags.length ? <meta name="keywords" content={tags.join(", ")} /> : null}

    <!-- OG / Twitter -->
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={`/og/${slug}.png`} />
    <meta property="twitter:card" content="summary_large_image" />

    <link rel="canonical" href={new URL(Astro.url.pathname, Astro.site)} />

    <!-- KaTeX -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
      integrity="sha384-yF2FqZkVQvGv8sU6sYxE/0H2Jf9W7G4m1nQqR2If1mQxBvQxw9S9WwZ3/NjZC0ay"
      crossorigin="anonymous"
    />

    <!-- JSON-LD (only include dates if valid) -->
    <script type="application/ld+json" is:inline>
      {JSON.stringify({
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        headline: title,
        description,
        ...(publishedISO ? { datePublished: publishedISO } : {}),
        ...(updatedISO ? { dateModified: updatedISO } : publishedISO ? { dateModified: publishedISO } : {}),
        mainEntityOfPage: new URL(Astro.url.pathname, Astro.site).toString(),
        articleSection: tags
      })}
    </script>
  </Fragment>

  <article class="prose prose-neutral dark:prose-invert max-w-none pt-8 md:pt-10 lg:pt-12">
    <a href="/" class="inline-block mb-3 text-sm hover:underline">← Home</a>

    <h1>{title}</h1>

    <p class="!mt-0 text-sm opacity-70">
      {pub ? <time datetime={publishedISO}>{human(pub)}</time> : null}
      {upd ? (
        <>
          {" • Updated "}
          <time datetime={updatedISO}>{human(upd)}</time>
        </>
      ) : null}
    </p>

    {tags.length > 0 && (
      <div class="mt-2 text-xs opacity-70 flex items-center gap-2 flex-wrap">
        {tags.map((t) => (
          <a
            href={`/tags/${t}`}
            class="px-2 py-0.5 border rounded no-underline hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
          >
            {t}
          </a>
        ))}
      </div>
    )}

    <slot />

    <!-- Divider before comments -->
    <hr class="my-10 border-black/10 dark:border-white/10" />

    <!-- Comments: same width as post -->
    <section id="comments" class="mt-8">
      <!-- Wrapper fills remaining viewport so no large blank area below -->
      <div id="comments-fill">
        <Cusdis title={title} />
      </div>
    </section>

    <!-- Make the comments block fill remaining viewport height -->
    <script is:inline>
      (function () {
        const commentsFill = document.getElementById('comments-fill');
        if (!commentsFill) return;

        function fillRest() {
          // distance from top of viewport to top of the comments wrapper
          const rect = commentsFill.getBoundingClientRect();
          const topFromViewport = rect.top;
          const padding = 24; // little breathing room at bottom
          const min = Math.max(420, Math.floor(window.innerHeight - topFromViewport - padding));
          commentsFill.style.minHeight = min + 'px';
        }

        // initial + on resize/orientation
        fillRest();
        window.addEventListener('resize', fillRest);
        window.addEventListener('orientationchange', fillRest);

        // re-run after fonts/layout shifts
        setTimeout(fillRest, 50);
        setTimeout(fillRest, 250);
      })();
    </script>
  </article>
</BaseLayout>
